#import "@preview/frame-it:2.0.0": divide, frame-style, styles
#import "@preview/cetz:0.3.4"

#import "lib.typ": (
  adt, algorithm, background, backgroundBase, definition, example, invariant,
  operation,
)

#set text(font: "LXGW WenKai", 12pt)
#set page(numbering: "1/1")
#show: frame-style(styles.boxy)

= 图例

#linebreak()

#backgroundBase(numbering: none)[背景知识][#text(
  11pt,
  rgb("#222"),
)[这是一个背景知识。]]

#example(numbering: none)[例子][这是一个例子。]

#invariant(numbering: none)[不变量][
  这里会写一些性质。
  #divide()
  这里可能会有一些人话版。
]

#definition(
  numbering: none,
)[定义][这是一个定义。#divide() 通常底下会有一句人话版。]

#algorithm(numbering: none)[算法][$O(f(n))$][
  算法相关的东西
]

#adt(
  name: "某个数据结构的名字",
  methods: [
    #operation(numbering: none)[
      某个方法的名字
    ][$O(f(n))$][这个方法的介绍]
  ],
)

#pagebreak()

= 聊点基础的东西

== 计算机存储体系和数据结构

讲一点内存的性质，因为数据结构通常都是设计被放在内存里的，
也是根据内存的存储特性进行设计的。

#background[计算机存储金字塔][
  计算机的存储体系被设计成一个金字塔结构。

  计算机里的数据都是从外存读到内存，再从内存读到寄存器/缓存，
  然后 CPU 才会从寄存器/缓存拿到的。
  这样的话，对同一个数据进行反复操作的时候，
  就不用反复读写很慢的硬盘了。
]

内存有几个很重要的特性（与机械硬盘对比）：
- *随机访问*：内存是一个按字节编址的线性空间，
  它访问任何一个地址的时间基本一致。
- *空间局部性*：现代 CPU 取东西的时候会顺便把旁边的东西也预取出来，
  因此访问比较近的内存比访问更远的会快一些。（这也是链表为什么慢一点）
- 易失性：断电数据就丢了。

讲到内存地址通常记作形如 `0x30000000` 的 16 进制数字的时候，
发现需要补一下关于数制的概念。

#background[数制][
  简单来说，n 进制就是“满 n 进 1”的计数规则。在 n 进制中，
  人们使用 n 个符号表示一个数字。如在二进制中，使用了 `0`, `1` 两个符号。

  #example[位值制][
    这里写一下同一个数字（十进制下的 13）在不同进制下的表示。
    #let b(something) = text(blue)[#something]

    #table(
      columns: (auto, 1.2fr, 0.8fr),
      inset: 10pt,
      align: (col, row) => if col == 1 { left } else { center },
      stroke: 0.5pt + gray,
      fill: (x, y) => if y == 0 { gray.lighten(90%) },
      [*进制*], [*按权展开式的意义 (权重的组合)*], [*在该进制下的表示*],
      [2],
      [$#b[1] dot 2^3 + #b[1] dot 2^2 + #b[0] dot 2^1 + #b[1] dot 2^0$],
      [$(#b[1101])_2$],

      [10], [$#b[1] dot 10^1 + #b[3] dot 10^0$], [$(#b[13])_(10)$],
      [16], [$#b[13] dot 16^0 arrow.r #b[D] dot 16^0$], [$(#b[D])_(16)$],
    )
  ]

  使用十六进制通常是为了让人方便看，
  因为十六进制的 1 个字符*一一对应*于二进制的 4 个字符。
  比如当说到 $("A"3)_(16)$ 的时候，这个数字其实是 $(10100011)_(2)$。

  总是写 $\(\)_(16)$ 也很麻烦，所以也用 `0xA3` 表示 $("A"3)_(16)$。
  这里的 x 是十六进制 (he#text(blue, weight: "bold")[x]adecimal) 的意思。
]

== 抽象数据类型

然后说说为什么有*抽象数据类型 (Abstract Data Type, ADT)* 这个东西。

因为不同计算机或者语言之间差别很大，
而写程序的人希望关心数据本身的性质，
而不是在每个不同的地方它们的表现。

比如对于矩阵
$
  mat(
    1, 2, 3;
    4, 5, 6;
    7, 8, 9;
  )
$
在 C 语言里，数据在内存上是这么放的（Recall：内存是一个*线性模型*）：
```
1 2 3 4 5 6 7 8 9
```
在 Fortran 语言里，则是这么放的：
```
1 4 7 2 5 8 3 6 9
```

#background[矩阵的存储方式][
  上面介绍的两种存储矩阵的方式没有对错之分。
  像 C 语言这样逐行存储的做法被称作*行主序*，
  而像 Fortran 这样的做法被称作*列主序*。
]

如果我们想要计算这个矩阵第三列的和，
那在 C 中就要做
```
a[0][2] + a[1][2] + a[2][2] = a[2] + a[5] + a[8]
```
而在 Fortran 中则是
```
a[2][0] + a[2][1] + a[2][2] = a[6] + a[7] + a[8]
```

这个显然是挺恶心的一件事，但是数据本身的结构是清晰的，
所以如果我们抽象出一个叫做*矩阵*的东西，
在计算的时候就在两边都只关心 `sum matrix.col(3)` 就可以了。
由这个抽象数据类型的实现者负责把 `col(3)` 这个东西翻译到两个语言里不同的实现去。

= 编程范式

简单说一下这个东西，
是因为数据结构这个东西本身是带有强烈的*面向对象*的风格的。

#table(
  columns: (auto, auto),
  inset: 10pt,
  align: (col, row) => if col == 1 { left } else { center },
  stroke: 0.5pt + gray,
  fill: (x, y) => if y == 0 { gray.lighten(90%) },
  [C 风格（过程式，结构化编程）], [C++ 风格（面向对象编程）],
  [`写字(cuso4d, 字)`], [`cuso4d.写字(字)`],
)

在面向对象编程中，程序员认为程序是一系列相互作用的对象，
对象有自己的性质和能做的事情（方法）。
这个和数据结构想做的事情非常类似：
每个抽象数据类型都有自己能做的事情。

= 算法

#definition[算法][
  *算法*是为了解决某类问题而规定的一个*有限长*的*操作序列*。
  #divide()
  人话版的重点：能执行完，每一步都能让计算机知道怎么做的，操作序列。
]

#invariant[算法的一堆性质][
  一个算法必须满足以下5个重要特性。
  - *有穷性*。一个算法必须总是在执行有穷步后结束，且每一步都必须在有穷时间内完成。
  - *确定性*。对于每种情况下所应执行的操作，在算法中都有确切的规定，
    不会产生二义性，算法的执行者或阅读者都能明确其含义及如何执行。
  - *可行性*。算法中的所有操作都可以通过将已经实现的基本操作运算执行有限次来实现。
  - *输入*。一个算法有0个或多个输入。
  - *输出*。一个算法有一个或多个输出，它们是算法进行信息加工后得到的结果，
    无输出的算法没有任何意义。

    #divide()

  - *有穷性*。不能死循环。
  - *确定性*。不能写“加少许盐”，要写“加 2g NaCl”。
  - *可行性*。不能写“预测明天的彩票号码”，因为计算机做不到。
  - *输入*。算法是用来处理东西的。
  - *输出*。算法处理完得有个结果。
]

衡量算法好坏的直观看法就是算法能跑多快，
但是算法输入有时候大有时候小，怎么做呢？
有一个办法就是观察“数据量翻倍的时候，时间会怎么翻倍”。

#definition[基本语句][
  基本语句”指的是算法中重复执行次数和算法的执行时间成正比的语句，
  它对算法运行时间的贡献最大。
  #divide()
  就是这个算法里单次运行耗时比较大的语句，它之后会被当成 $O(1)$。
  #example[随便举个例子][
    我回家之后可能会开灯，打游戏。
    这两个玩意放一起的时候，打游戏就是那个基本语句。
    因为通常来说，我开 1 次灯打 1 次游戏要用 2h，
    我开 100 次灯再打 1 次游戏要用 2h 1min。
    但是我要是开 1 次灯打 2 次游戏那就要用 4h 了。
  ]
]

#definition[时间复杂度][
  一般情况下，算法中基本语句重复执行的次数是问题规模 $n$ 的某个函数$f(n)$，
  算法的时间量度记作：
  $ T(n) = O(f(n)). $
  它表示随着问题规模 $n$ 的增大，算法执行时间的增长率和 $f(n)$ 的增长率相同，
  称作算法的渐近时间复杂度，简称时间复杂度。

  #divide()
  就是说随着输入规模变大的时候，从长远来看（不管小输入的时候如何），
  需要的时间会增加得多快。
  #example[用数字举个例子][
    #align(center)[
      #table(
        columns: (auto, auto, auto, 1.4fr, auto),
        inset: 10pt,
        align: horizon,
        stroke: 0.5pt + gray,
        fill: (x, y) => if y == 0 { gray.lighten(90%) },
        [*输入规模 $n$*],
        [*$n = O(n)$*],
        [*$n^2 = O(n^2)$*],
        [*$10n^2 + 100 = O(n^2)$*],
        [*$2^n = O(2^n)$*],

        [10], [10], [100], [1,100], [1,024],

        [100], [100], [10,000], [100,100], [$1.27 times 10^30$],

        [1000], [1000], [1,000,000], [10,000,100], [$1.07 times 10^301$],
      )
    ]
    在这个例子里，$10 n^2$ 的部分虽然最开始和 $2^n$ 差不多，
    但是数据量增大的时候很快就被甩开了，然后它和 $n^2$ 越来越趋于一致。

    因此在粗粒度考虑的时候，只关注 $O(f(n))$ 就可以了，
    常系数和后面阶数更低的项不是很需要关心。
  ]
]

#example[矩阵乘法][$O(n^3)$][
  以这个算法为例子，分析它的时间复杂度。

  ```python
  for i in range(n):                    # n + 1
      for j in range(n):                # (n + 1) * n
          sum = 0                       # n * n
          for k in range(n):            # (n + 1) * n * n
              sum += A[i][k] * B[k][j]  # n * n * n
          C[i][j] = sum                 # n * n
  ```

  这里的基本语句是乘法和赋值那句，所以 $ T(n) = n^3 = O(n^3). $
]

= 串

串也被翻译成字符串，它也是一个特殊的线性表。
（Recall：栈和队列是被 ban 掉了某些操作的线性表）
串是要求数据元素都得是字符的线性表。
#text(size: 10pt)[后文中使用 $Sigma$ 代表字符的集合。]

做这个抽象我觉得有三个原因：
- 字符串这个东西比较常用；
- 字符串有一些很常用的操作不是线性表的基本操作。比如子串匹配。
- 处理字符和处理数值在计算机上的实现不同，因此会引入新的存储结构。

#definition[串][
  *串*是由零个或多个字符组成的有限序列。一般记为：
  $ s = a_1 a_2 dots a_n. (n >= 0) $
  若串由零个字符组成，称为*空串*，后文中记为 $s = emptyset$。

  #divide()

  重点就是 0+ 个字符（0 个也算），有限（不可以无限长），
  序列（有顺序，和集合相对）。
]

#definition[子串][
  串里任意个连续的字符组成的子序列称为该串的子串。
]

#adt(
  name: "串",
  elements: [$D = {a_i | a_i in Sigma}, i = 1, dots, n, n >= 0.$],
  relations: [和线性表一样],
  methods: [
    #operation[`s.copy() -> str`][$O(n)$][
      复制自己得到一个新串。
    ]
    #operation[`s.compare(t: str) -> int`][$O(n)$][
      比较自己和另一个串的大小。返回它们差了多远。
      #show: frame-style(styles.boxy)
      #background[字典序][
        先定义字符的顺序：`0 < 1 < ... < 9 < A < ... < Z < a < ... < z`。

        字符串的序关系是：从最前面的字符开始比，
        一直比到第一个不一样的字符，这时候谁的这个字符大谁就大。
        如果有一个字符串更短，先结束了（即它是另一个的前缀），那先结束的那个小。
        比如：apple < apples, apple < applf.
      ]
      #show: frame-style(styles.thmbox)
    ]
    #operation[`s.length() -> int`][$O(n)$][
      返回自己的长度。
    ]
    #operation[`s.concat(s2: str) -> str`][$O(n + m)$][
      返回自己和另一个串的拼接。
    ]
  ],
)

== 存储结构

首先串是特殊的线性表，所以和线性表一样有很基本的顺序存储和链式存储。

不过由于链式存储的时候如果一个节点只存一个字符那也太浪费空间了，
很多时候链串里的一个节点可以放好几个字符。这是通常线性表不会做的。

== 子串匹配

经常会遇到一个问题就是一个字符串是不是另一个字符串的子串。

这时候这个拿来检验的子串也叫做模式 (pattern) 串。

例子：在主串 `ABABABC` 中找是否存在子串 `ABABC`。

#algorithm[BF 算法进行子串匹配][$O(m * n)$][
  把子串和主串从第一位开始对齐，依次往后比，
  出现失配的时候，就把子串往右挪一次再比。

  直到如果某次子串全匹配了就是存在，如果到最后都没全匹配就是不存在。

  ```
  a b a b a b c
  a b a b c
  = = = = ^

  a b a b a b c
    a b a b c
    ^

  a b a b a b c
      a b a b c
      = = = = =
  ```
]

#algorithm[KMP 算法][$O(m + n)$][
  别的和 BF 一样，但是如果出现不匹配的时候，利用之前比过的信息。

  根据模式串的结构，在失配的位置，模式串的末尾和开头都是 `AB`，
  那这个时候，虽然失配了，但是我们知道主串失配前那个位置都是匹配的，
  也就是我们知道模式串的开头肯定和主串失配前的位置是匹配的。

  所以模式串可以往后退很多，不用只挪一个格子。

  ```
   a b  [a b] a b c
  [a b] [a b] c
   = =   = =  ^

  a b [a b] a b c
      [a b] a b c
            = = =
  ```
]

KMP 算法为了实现我们刚刚说到的这个直觉，引入了一个 `next` 数组。
这个数组是用来分析模式串的结构的：当模式串在第 `j` 个位置失配时，
前面的子串里，最长的一模一样的头尾有多长。

对于上面的例子 `ABABC`，
`next = [0, 0, 0, 1, 2]`，
也就是说，如果在 `C` 失配了，可以直接把模式串的 `[2]` 位置给对到主串的指针上去。

== 更强大的子串匹配

有些时候搜索的要求更高，不一定是子串，
但是可能是有一些特殊的结构的。

#example[找到文本里的取件码][
  取件码短信格式还挺多的。
  - 【菜鸟驿站】您的快递已到达，取件码 9-2-4015，请及时领取。
  - [顺丰速运] 凭 1-2-3018 到店取件。

  我们只知道取件码的格式是 `数字-数字-4个数字`。
  事实上有人创造出了一种表示这种需求的语言，称为*正则表达式*。
]

#background[正则表达式][
  每一条正则表达式代表着一类可能的字符串。刚才的取件码可以被表示为：
  `\d-\d-\d{4}`，其中 `\d` 表示数字，`{4}` 表示前边的东西要出现 4 次。

  在实现的时候，上面的这个正则表达式会被转换成这样的一个状态机：

  #import "@preview/cetz:0.3.4"

  #cetz.canvas({
    import cetz.draw: *

    set-style(
      circle: (radius: 0.4),
      line: (mark: (end: ">"), stroke: 0.5pt),
      content: (padding: .1),
    )

    let state(pos, lbl, name, is_final: false) = {
      group(name: name, {
        circle(pos, name: "c", stroke: if is_final { 2pt } else { 0.5pt })
        content("c", lbl)
      })
    }

    state((0, 0), [S0], "s0")
    state((2, 0), [S1], "s1")
    state((4, 0), [S2], "s2")
    state((6, 0), [S3], "s3")
    state((8, 0), [S4], "s4")

    line("s0", "s1", name: "l1")
    content("l1", [digit], anchor: "south")
    line("s1", "s2", name: "l2")
    content("l2", [-], anchor: "south")
    line("s2", "s3", name: "l3")
    content("l3", [digit], anchor: "south")
    line("s3", "s4", name: "l4")
    content("l4", [-], anchor: "south")

    state((8, -2), [S5], "s5")
    state((6, -2), [S6], "s6")
    state((4, -2), [S7], "s7")
    state((2, -2), [S8], "s8", is_final: true)

    line("s4", "s5", name: "l_turn")
    content("l_turn", [digit], anchor: "west")

    line("s5", "s6", name: "l5")
    content("l5", [digit], anchor: "north")
    line("s6", "s7", name: "l6")
    content("l6", [digit], anchor: "north")
    line("s7", "s8", name: "l7")
    content("l7", [digit], anchor: "north")
  })
]
